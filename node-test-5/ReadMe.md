# 进程
- 进程是程序执行的实例
- 程序在CPU上执行时的活动叫做进程

### 特点
1. 一个进程可以创建另一个进程（父进程和子进程）
2. 通过任务管理器可以看到进程关系

### 了解CPU

特点:

- 一个单核CPU，在一个时刻，只能做一个事情
- 那么操作系统如何同时执行几个进程呢？答案是在不同的进程中快速切换

多程序并发执行：

- 指多个程序在宏观上并行，在微观上串行
- 每个进程会出现[执行-暂停-执行]的规律
- 多个进程之间会出现抢资源的现象

进程储存再进程队列中，分派给CPU进行运行，运行结束的退出，未结束的过程中如果CPU需要执行其他进程，则当前进程暂停，重新进入进程队列

### 阻塞

进程在等待的过程中CPU要挑选一个进程去执行，由于一些操作例如IO操作未完成而放到进程队列中就会发生阻塞。

等待整形的进程中，都是非运行态，一些(A)在等待CPU资源，另一些（B）在等待IO完成（如文件读取），如果这个时候把CPU分配给B进程B还是在等IO，我们把这个B叫做阻塞进程。因此分派程序只会把CPU分配给非阻塞进程。

进程三种状态： 运行、暂停、阻塞

## 线程

线程的引入：

分阶段：

1. 在面向进程设计的系统中，进程是程序的基本执行实体
2. 在面向线程设计的系统中，进程本身不是基本运行单位，二十线程的容器

最开始进程是执行的基本实体，同时进程也是资源分配的基本实体。但是如果要同时做很多相似的事情，要开很多进程从而导致进程的创建、切换、销毁等操作太消耗CPU时间，于是引入线程作为执行的基本实体，而进程只作为资源分配的基本实体。

### 概念

- CPU调度和执行的最小单元
- 一个进程中至少有一个线程，可以有多个线程
- 一个进程中的线程共享改进程的所有资源
- 进程的第一个线程叫做初始化线程
- 线程的调度可以由操作系统负责，也可以由用户自己负责

总结来说线程就是轻量级的进程，线程可以共享进程的资源。

子进程和线程优先使用线程，除非单独开一个资源分配，再使用子进程

## 使用Nodejs控制子进程
1. `child_process exec`

    exec返回`stdout stderr`个流，可以对`stdout stderr`用`data`事件进行监听。
可以使用`util.promisify`进行包裹，变成Promise

    exec很危险，可能会被用户注入程序，应该用`execFile`。
    
2. `execFile`
    
    通过数组的形式传入方法，防止传入奇怪操作
    
    options: 
    
        1. cwd: 命令要在那个目录下执行
        2. env: 环境变量
        3. shell: 用什么东西执行当前命令(git bash, cmd等等)
        4. maxBuffer: 最大缓存，回调形式中，执行过程中得出的结果是存在一个缓存里再统一返回，这时候就有一个最大buffer，默认是1024*1024字节
        
3. spawn
    
    用法与`execFile`基本一致，但是没有回调函数，只能通过流事件获取结果，没有最大200kb限制。
    能用`spawn`就不要用`execFile`。
    
4. fork

   创建一个只能执行Node脚本的子进程
   
   `fork(./exec.js)`相当于`spawn('node', ['./child.js'])`。
   
   特点：可以进行通讯
   - `message`事件
   - `send`事件


